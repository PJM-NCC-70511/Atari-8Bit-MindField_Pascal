STACKWIDTH	= 16
CODEORIGIN	= $8000

TRUE		= 1
FALSE		= 0

	org $C0

	.print 'ZPFREE: $0000..',*-1

fxptr	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4
bp	.ds 2
bp2	.ds 2

ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

TMP	.ds 2

	org $0080

STACKORIGIN	.ds STACKWIDTH*4

	.print 'ZPFREE: ',*,'..',$ff

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

.local	RESOURCE
	icl 'res6502.asm'

	RCDATA 'MINDFIELD.FNT' CHARSET_GAME 0 0 0 0 0 0 0 0
	RCDATA 'MIND FIELD TITLE.FNT' CHARSET_TITLE 0 0 0 0 0 0 0 0
	RCDATA 'Mind Field Title Screen.txt' TITLE_DATA 0 0 0 0 0 0 0 0
	RCASM 'sound_commander.asm' SOUND_COMMANDER 0 0 0 0 0 0 0 0
.endl

; -----------------------------------------------------------

	org CODEORIGIN

	STATICDATA

START
	tsx
	stx MAIN.@halt+1

	.ifdef fmulinit
	fmulinit
	eif

	ift DATAORIGIN+VARINITSIZE > $BFFF
	ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
	els
	@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
	eif

	ldx #$0f
	mva:rpl $340,x MAIN.IOCB@COPY,x-

	mvx #$00 bp					; lo BP = 0, X = 0 !!!

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	ift l_013C-*>3
	jmp l_013C
	eif

; -----------------------------------------------------------

.local	SYSTEM						; UNIT

.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 004  ---------------------

	ldy #0
	mva (edx),y Result


@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

A	= edx
RESULT	= DATAORIGIN+$000A

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	RANDOM_0146					; FUNCTION | ASSEMBLER | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x RANGE
	dex						; sub bx, 1


; ---------------------  ASM Block 009  ---------------------


;BYTE FUNC Rand(BYTE range)
; returns random number between 0 and
; range-1.  If range=0, then a random
; number between 0 and 255 is returned

	ldy	$d20a		; RANDOM

	lda	range
	beq	stop

	sta	ecx
	sty	eax

	jsr	imulCL
	tay

stop	sty	Result


@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RANGE	= DATAORIGIN+$000B
RESULT	= DATAORIGIN+$000C

@VarData	= RANGE
@VarDataSize	= 2

	rts						; ret
.endl

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 021  ---------------------

	ldy #0
	mva value (edx),y


; -----------------------------------------------------------

A	= edx
VALUE	= ecx

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	DPOKE						; PROCEDURE | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VALUE
	mva :STACKORIGIN+STACKWIDTH,x VALUE+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 022  ---------------------

	ldy #0
	mva value (edx),y
	iny
	mva value+1 (edx),y


; -----------------------------------------------------------

A	= edx
VALUE	= ecx

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLCHAR_0184					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 024  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	FILLBYTE_0197					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex						; sub bx, 1


; ---------------------  ASM Block 029  ---------------------

	jsr @fill


; -----------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MOVE_01AA					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex						; sub bx, 1


; ---------------------  ASM Block 033  ---------------------

	jsr @move


; -----------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $0004
MGTIA	= $0000
MVBXE	= $0080
WINDOW	= $0010
NARROW	= $0020
VBXE_XDLADR	= $0000
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $0000
IVBL	= $0001
CH_DELCHR	= $00FE
CH_ENTER	= $009B
CH_ESC	= $001B
CH_CURS_UP	= $001C
CH_CURS_DOWN	= $001D
CH_CURS_LEFT	= $001E
CH_CURS_RIGHT	= $001F
CH_TAB	= $007F
CH_EOL	= $009B
CH_CLR	= $007D
CH_BELL	= $00FD
CH_DEL	= $007E
CH_DELLINE	= $009C
CH_INSLINE	= $009D
COLOR_BLACK	= $0000
COLOR_WHITE	= $000E
COLOR_RED	= $0032
COLOR_CYAN	= $0096
COLOR_VIOLET	= $0068
COLOR_GREEN	= $00C4
COLOR_BLUE	= $0074
COLOR_YELLOW	= $00EE
COLOR_ORANGE	= $004A
COLOR_BROWN	= $00E4
COLOR_LIGHTRED	= $003C
COLOR_GRAY1	= $0004
COLOR_GRAY2	= $0006
COLOR_GRAY3	= $000A
COLOR_LIGHTGREEN	= $00CC
COLOR_LIGHTBLUE	= $007C
FMOPENREAD	= $0004
FMOPENWRITE	= $0008
FMOPENAPPEND	= $0009
FMOPENREADWRITE	= $000C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
FILEMODE	= DATAORIGIN+$0004
SCREENMODE	= DATAORIGIN+$0005
IORESULT	= DATAORIGIN+$0006
EOLN	= DATAORIGIN+$0007
RNDSEED	= DATAORIGIN+$0008

.endl							; UNIT SYSTEM

; -----------------------------------------------------------

.local	ATARI						; UNIT

; -----------------------------------------------------------

RTCLOK	= $0012
ATRACT	= $004D
LMARGIN	= $0052
RMARGIN	= $0053
ROWCRS	= $0054
COLCRS	= $0055
DINDEX	= $0057
SAVMSC	= $0058
VDSLST	= $0200
VPRCED	= $0202
VINTER	= $0204
VBREAK	= $0206
VKEYBD	= $0208
VSERIN	= $020A
VSEROR	= $020C
VSEROC	= $020E
VTIMR1	= $0210
VTIMR2	= $0212
VTIMR3	= $0214
VIMIRQ	= $0216
CDTMV1	= $0218
CDTMV2	= $021A
CDTMV3	= $021C
CDTMV4	= $022E
CDTMV5	= $0220
VVBLKI	= $0222
VVBLKD	= $0224
CDTMA1	= $0226
CDTMA2	= $0228
SDNCTK	= $022F
SDLSTW	= $0230
SDLSTL	= $0230
SDLSTH	= $0231
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
PAL	= $D014
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
STIMER	= $D209
SKRES	= $D20A
POTGO	= $D20B
SEROUT	= $D20D
IRQEN	= $D20E
SKCTL	= $D20F
SKSTAT	= $D20F
POT0	= $D200
POT1	= $D201
POT2	= $D202
POT3	= $D203
POT4	= $D204
POT5	= $D205
POT6	= $D206
POT7	= $D207
ALLPOT	= $D208
POTST	= $D208
KBCODE	= $D209
RANDOM	= $D20A
SERIN	= $D20D
IRQST	= $D20E
PORTA	= $D300
PORTB	= $D301
PCCTL	= $D302
PBCTL	= $D303
DMACTL	= $D400
CHACTL	= $D401
DLISTW	= $D402
DLISTL	= $D402
DLISTH	= $D403
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIRES	= $D40F
NMIST	= $D40F

.endl							; UNIT ATARI

; -----------------------------------------------------------

.local	B_SYSTEM					; UNIT

.local	SETCHARSET					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x MSB
	dex						; sub bx, 1

	ift l_01D0-*>3
	jmp l_01D0
	eif

; IfThenEpilog
l_01D0

; optimize OK (B_SYSTEM), line = 218

	mva MSB ATARI.CHBASE

; -----------------------------------------------------------

MSB	= DATAORIGIN+$000E

@VarData	= MSB
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$000D
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SYSTEM

; -----------------------------------------------------------

.local	SYSUTILS					; UNIT

.local	INTTOSTR					; FUNCTION | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	mva :STACKORIGIN+STACKWIDTH*2,x A+2
	mva :STACKORIGIN+STACKWIDTH*3,x A+3
	dex						; sub bx, 1


; ---------------------  ASM Block 060  ---------------------

	txa:pha

	inx

	@ValueToStr #@printINT

	mwa #@buf Result

	pla:tax


@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

A	= DATAORIGIN+$000F
RESULT	= DATAORIGIN+$0013

@VarData	= A
@VarDataSize	= 6

	rts						; ret
.endl

; -----------------------------------------------------------

FAREADONLY	= $0001
FAHIDDEN	= $0002
FASYSFILE	= $0004
FAVOLUMEID	= $0008
FADIRECTORY	= $0010
FAARCHIVE	= $0020
FAANYFILE	= $003F

.endl							; UNIT SYSUTILS

; -----------------------------------------------------------

.local	B_CRT						; UNIT

.local	ATASCII2ANTIC_01F1				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_01FA-*>3
	jmp l_01FA
	eif

; IfThenEpilog
l_01FA

; ---------------------  ASM Block 064  ---------------------


        lda c
        asl
        php
        cmp #2*$60
        bcs @+
        sbc #2*$20-1
        bcs @+
        adc #2*$60
@       plp
        ror
        sta result;
    

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

C	= DATAORIGIN+$001E
RESULT	= DATAORIGIN+$001F

@VarData	= C
@VarDataSize	= 2

	rts						; ret
.endl

.local	ATASCII2ANTIC_01FE				; FUNCTION | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_0207-*>3
	jmp l_0207
	eif

; IfThenEpilog
l_0207

; optimize OK (B_CRT), line = 468

	lda adr.S+$00
	sta adr.RESULT+$00
; For

; optimize OK (B_CRT), line = 469

	mva #$01 I

; optimize OK (B_CRT), line = 469

	lda adr.S+$00
	sta @FORTMP_539
; To
l_0221

; ForToDoCondition

; optimize OK (B_CRT), line = 469

	lda I
	cmp @FORTMP_539
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_022F

; optimize FAIL ('ATASCII2ANTIC_01F1', B_CRT), line = 470
	inx
	mva I :STACKORIGIN,x
	inx
	ldy I 
	mva adr.S,y :STACKORIGIN,x
	jsr ATASCII2ANTIC_01F1
	ldy :STACKORIGIN-1,x
	mva :STACKORIGIN,x adr.RESULT,y
	dex
	dex

; ForToDoEpilog
c_0221
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0221
l_022F
b_0221

@exit

; -----------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$0020
.var S	= adr.S .word
adr.RESULT	= DATAORIGIN+$0120
.var RESULT	= adr.RESULT .word
I	= DATAORIGIN+$0220
@FORTMP_539	= DATAORIGIN+$0221

@VarData	= S
@VarDataSize	= 514

	rts						; ret
.endl

.local	CRT_INIT_0245					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x HEIGHT
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x WIDTH
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VRAM_ADDRESS
	mva :STACKORIGIN+STACKWIDTH,x VRAM_ADDRESS+1
	dex						; sub bx, 1

	ift l_025A-*>3
	jmp l_025A
	eif

; IfThenEpilog
l_025A

; optimize OK (B_CRT), line = 483

	mva VRAM_ADDRESS CRT_VRAM
	mva VRAM_ADDRESS+1 CRT_VRAM+1

; optimize OK (B_CRT), line = 484

	mva WIDTH CRT_SCREENWIDTH

; optimize OK (B_CRT), line = 485

	mva HEIGHT CRT_SCREENHEIGHT

; optimize OK (B_CRT), line = 486

	lda HEIGHT
	sta :ecx
	lda WIDTH
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta CRT_SIZE
	lda :eax+1
	sta CRT_SIZE+1

; optimize OK (B_CRT), line = 487

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

; optimize OK (B_CRT), line = 488

	mva #$00 CRT_LEFTMARGIN

; -----------------------------------------------------------

VRAM_ADDRESS	= DATAORIGIN+$0222
WIDTH	= DATAORIGIN+$0224
HEIGHT	= DATAORIGIN+$0225

@VarData	= VRAM_ADDRESS
@VarDataSize	= 4


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_CLEAR_0293					; PROCEDURE | OVERLOAD

	ift l_0296-*>3
	jmp l_0296
	eif

; IfThenEpilog
l_0296

; optimize OK (B_CRT), line = 504

	lda CRT_VRAM
	sta :edx
	lda CRT_VRAM+1
	sta :edx+1
	lda CRT_SIZE
	sta :ecx
	lda CRT_SIZE+1
	sta :ecx+1
	lda #$00
	sta :eax
	jsr @fill

; optimize OK (B_CRT), line = 505

	mva CRT_VRAM CRT_CURSOR
	mva CRT_VRAM+1 CRT_CURSOR+1

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_GOTOXY					; PROCEDURE

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x Y
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x X
	dex						; sub bx, 1

	ift l_02B4-*>3
	jmp l_02B4
	eif

; IfThenEpilog
l_02B4

; optimize OK (B_CRT), line = 516

	lda CRT_SCREENWIDTH
	sta :ecx
	lda Y
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	add X
	sta :STACKORIGIN+9
	lda :eax+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add CRT_VRAM
	sta CRT_CURSOR
	lda :STACKORIGIN+STACKWIDTH+9
	adc CRT_VRAM+1
	sta CRT_CURSOR+1

; -----------------------------------------------------------

X	= DATAORIGIN+$0226
Y	= DATAORIGIN+$0227

@VarData	= X
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02CF					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex						; sub bx, 1
	@move S #adr.S #256
	mwa #adr.S S

	ift l_02D8-*>3
	jmp l_02D8
	eif

; IfThenEpilog
l_02D8

; optimize OK (B_CRT), line = 531

	lda S
	add #$01
	sta :edx
	lda S+1
	adc #$00
	sta :edx+1
	lda adr.S+$00
	sta :eax
	lda CRT_CURSOR
	sta :ecx
	lda CRT_CURSOR+1
	sta :ecx+1
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (B_CRT), line = 532

	lda CRT_CURSOR
	add adr.S+$00
	sta CRT_CURSOR
	lda CRT_CURSOR+1
	adc #$00
	sta CRT_CURSOR+1

; -----------------------------------------------------------

adr.S	= DATAORIGIN+$0228
.var S	= adr.S .word

@VarData	= S
@VarDataSize	= 256


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02E5					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x C
	dex						; sub bx, 1

	ift l_02EE-*>3
	jmp l_02EE
	eif

; IfThenEpilog
l_02EE

; optimize OK (B_CRT), line = 537

	lda CRT_CURSOR+1
	sta :bp+1
	ldy CRT_CURSOR
	lda C
	sta (:bp),y

; optimize FAIL (0, B_CRT), line = 538
	inw CRT_CURSOR

; -----------------------------------------------------------

C	= DATAORIGIN+$0328

@VarData	= C
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_02F9					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x NUM
	dex						; sub bx, 1

	ift l_0302-*>3
	jmp l_0302
	eif

; IfThenEpilog
l_0302

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 543
	inx
	mva NUM :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01FE
	jsr CRT_WRITE_02CF

; -----------------------------------------------------------

NUM	= DATAORIGIN+$0329

@VarData	= NUM
@VarDataSize	= 1


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_WRITE_0309					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x NUM
	mva :STACKORIGIN+STACKWIDTH,x NUM+1
	dex						; sub bx, 1

	ift l_0312-*>3
	jmp l_0312
	eif

; IfThenEpilog
l_0312

; optimize FAIL ('SYSUTILS.INTTOSTR', B_CRT), line = 548
	inx
	mva NUM :STACKORIGIN,x
	mva NUM+1 :STACKORIGIN+STACKWIDTH,x
	jsr @expandToCARD.WORD
	jsr SYSUTILS.INTTOSTR
	jsr ATASCII2ANTIC_01FE
	jsr CRT_WRITE_02CF

; -----------------------------------------------------------

NUM	= DATAORIGIN+$032A

@VarData	= NUM
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	CRT_KEYPRESSED					; FUNCTION

	ift l_031B-*>3
	jmp l_031B
	eif

; IfThenEpilog
l_031B

; optimize OK (B_CRT), line = 592

	mva #$00 RESULT

; optimize OK (B_CRT), line = 593

	lda ATARI.SKSTAT
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_28
	sty IFTMP_28
	eif
	tya
	bne *+5
	jmp l_0338

; optimize OK (B_CRT), line = 593

	mva #$01 RESULT

; IfThenEpilog
l_0338

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$032C

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	CRT_STARTPRESSED				; FUNCTION

	ift l_0352-*>3
	jmp l_0352
	eif

; IfThenEpilog
l_0352

; optimize OK (B_CRT), line = 749

	lda ATARI.CONSOL
	ldy #1
	and #$01
	beq @+
	dey
@
	sty RESULT

@exit

; -----------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx						; add bx, 1
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif

; -----------------------------------------------------------

RESULT	= DATAORIGIN+$032D

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

; -----------------------------------------------------------

DEFAULT_SCREENWIDTH	= $0028
DEFAULT_SCREENHEIGHT	= $0018
CHAR_RETURN	= $009B
CHAR_ESCAPE	= $001B
CHAR_BACKSPACE	= $007E
CHAR_TAB	= $007F
CHAR_INVERSE	= $0081
CHAR_CAPS	= $0082
ICHAR_RETURN	= $00DB
ICHAR_ESCAPE	= $005B
ICHAR_BACKSPACE	= $007E
ICHAR_TAB	= $007F
ICHAR_INVERSE	= $00C1
ICHAR_CAPS	= $00C2
adr.CRT_KEYCODE	= CODEORIGIN+$0135
.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
CRT_VRAM	= DATAORIGIN+$0015
CRT_SIZE	= DATAORIGIN+$0017
CRT_SCREENWIDTH	= DATAORIGIN+$0019
CRT_SCREENHEIGHT	= DATAORIGIN+$001A
CRT_CURSOR	= DATAORIGIN+$001B
CRT_LEFTMARGIN	= DATAORIGIN+$001D
KBCODE	= $D209
CONSOL	= $D01F

.endl							; UNIT B_CRT

; -----------------------------------------------------------

.local	B_PMG						; UNIT

.local	PMG_INIT_0369					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x GRACTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SDMCTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x BASE
	dex						; sub bx, 1

	ift l_037E-*>3
	jmp l_037E
	eif

; IfThenEpilog
l_037E

; optimize OK (B_PMG), line = 159

	mva BASE PMG_PMBASE

; optimize OK (B_PMG), line = 160

	lda #$00
	sta PMG_BASE
	lda BASE
	sta PMG_BASE+1

; optimize OK (B_PMG), line = 161

	mva GRACTL PMG_GRACTL

; optimize OK (B_PMG), line = 162

	lda PMG_SDMCTL_S
	and #$E0
	ora SDMCTL
	sta SDMCTL_FLAGS

; optimize OK (B_PMG), line = 163

	mva SDMCTL_FLAGS PMG_SDMCTL

; optimize OK (B_PMG), line = 164

	mva SDMCTL_FLAGS PMG_SDMCTL_S

; optimize OK (B_PMG), line = 165

	lda SDMCTL
	ldy #1
	and #$10
	bne @+
	dey
@
	.ifdef IFTMP_32
	sty IFTMP_32
	eif
	tya
	bne *+5
	jmp l_03D8

; optimize OK (B_PMG), line = 166

	mva #$01 PMG_ONELINE

; optimize OK (B_PMG), line = 167

	mva #$00 PMG_SIZE
	mva #$08 PMG_SIZE+1

; IfThenEpilog
l_03D8

; Restore conditional expression
	lda IFTMP_32

; else condition
	beq *+5						; je
	jmp l_03F0

; optimize OK (B_PMG), line = 169

	mva #$00 PMG_ONELINE

; optimize OK (B_PMG), line = 170

	sta PMG_SIZE
	mva #$04 PMG_SIZE+1

; IfThenEpilog
l_03F0

; -----------------------------------------------------------

BASE	= DATAORIGIN+$0333
SDMCTL	= DATAORIGIN+$0334
GRACTL	= DATAORIGIN+$0335
SDMCTL_FLAGS	= DATAORIGIN+$0336
IFTMP_32	= DATAORIGIN+$0337

@VarData	= BASE
@VarDataSize	= 5


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	PMG_INIT_03FF					; PROCEDURE | OVERLOAD

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SDMCTL
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x BASE
	dex						; sub bx, 1

	ift l_040E-*>3
	jmp l_040E
	eif

; IfThenEpilog
l_040E

; optimize FAIL ('PMG_INIT_0369', B_PMG), line = 177
	inx
	mva BASE :STACKORIGIN,x
	inx
	mva SDMCTL :STACKORIGIN,x
	inx
	mva GRACTL :STACKORIGIN,x
	jsr PMG_INIT_0369

; -----------------------------------------------------------

BASE	= DATAORIGIN+$0338
SDMCTL	= DATAORIGIN+$0339
GRACTL	= DATAORIGIN+$033A

@VarData	= BASE
@VarDataSize	= 3


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

PMG_VDELAY_M0	= $0001
PMG_VDELAY_M1	= $0002
PMG_VDELAY_M2	= $0004
PMG_VDELAY_M3	= $0008
PMG_VDELAY_P0	= $0010
PMG_VDELAY_P1	= $0020
PMG_VDELAY_P2	= $0040
PMG_VDELAY_P3	= $0080
PMG_SIZE_NORMAL	= $0000
PMG_SIZE_X2	= $0001
PMG_SIZE_X4	= $0003
PMG_MSIZE0_X2	= $0001
PMG_MSIZE0_X4	= $0003
PMG_MSIZE1_X2	= $0004
PMG_MSIZE1_X4	= $000C
PMG_MSIZE2_X2	= $0010
PMG_MSIZE2_X4	= $0030
PMG_MSIZE3_X2	= $0040
PMG_MSIZE4_X4	= $00C0
PMG_GRACTL_MISSILES	= $0001
PMG_GRACTL_PLAYERS	= $0002
PMG_GRACTL_LATCH	= $0004
PMG_GRACTL_DEFAULT	= $0003
PMG_SDMCTL_DMA_MISSILE	= $0004
PMG_SDMCTL_DMA_PLAYER	= $0008
PMG_SDMCTL_DMA_BOTH	= $000C
PMG_SDMCTL_ONELINE	= $0010
PMG_SDMCTL_SCREEN_DISABLED	= $0000
PMG_SDMCTL_SCREEN_NARROW	= $0001
PMG_SDMCTL_SCREEN_NORMAL	= $0002
PMG_SDMCTL_SCREEN_WIDE	= $0003
PMG_SDMCTL_DEFAULT	= $000E
PMG_5PLAYER	= $0010
PMG_OVERLAP	= $0020
PMG_SDMCTL	= $D400
PMG_SDMCTL_S	= $022F
PMG_GPRIOR	= $D01B
PMG_GPRIOR_S	= $026F
PMG_PCOLR0	= $D012
PMG_PCOLR1	= $D013
PMG_PCOLR2	= $D014
PMG_PCOLR3	= $D015
PMG_PCOLR0_S	= $02C0
PMG_PCOLR1_S	= $02C1
PMG_PCOLR2_S	= $02C2
PMG_PCOLR3_S	= $02C3
PMG_HPOS0	= $D000
PMG_HPOS1	= $D001
PMG_HPOS2	= $D002
PMG_HPOS3	= $D003
PMG_HPOSM0	= $D004
PMG_HPOSM1	= $D005
PMG_HPOSM2	= $D006
PMG_HPOSM3	= $D007
PMG_SIZEP0	= $D008
PMG_SIZEP1	= $D009
PMG_SIZEP2	= $D00A
PMG_SIZEP3	= $D00B
PMG_SIZEM	= $D00C
PMG_GRAFP0	= $D00D
PMG_GRAFP1	= $D00E
PMG_GRAFP2	= $D00F
PMG_GRAFP3	= $D010
PMG_GRAFM	= $D011
PMG_P0PL	= $D00C
PMG_P1PL	= $D00D
PMG_P2PL	= $D00E
PMG_P3PL	= $D00F
PMG_VDELAY	= $D01C
PMG_GRACTL	= $D01D
PMG_HITCLR	= $D01E
PMG_PMBASE	= $D407
PMG_ONELINE	= DATAORIGIN+$032E
PMG_BASE	= DATAORIGIN+$032F
PMG_SIZE	= DATAORIGIN+$0331

.endl							; UNIT B_PMG

; -----------------------------------------------------------

.local	B_SET_INTERUPTS					; UNIT

.local	SETVBLI						; PROCEDURE | ASSEMBLER

; -----------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x VBLPTR
	mva :STACKORIGIN+STACKWIDTH,x VBLPTR+1
	dex						; sub bx, 1


; ---------------------  ASM Block 066  ---------------------


	mwa vblptr vvblki


; -----------------------------------------------------------

VBLPTR	= DATAORIGIN+$033C

@VarData	= VBLPTR
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; -----------------------------------------------------------

__NMIEN	= DATAORIGIN+$033B
PORTB_SELFTEST_OFF	= $0080
PORTB_BASIC_OFF	= $0002
PORTB_SYSTEM_ON	= $0001

.endl							; UNIT B_SET_INTERUPTS

.local	TITLEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 069  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		lda #$22
		sta colbak
		lda #$36
		sta colpf3				
		inc rtclok+2
		jmp XITVBV
	
	rti						; ret
.endl

.local	GAMEVBI						; PROCEDURE | INTERRUPT

	ift l_0424-*>3
	jmp l_0424
	eif

; IfThenEpilog
l_0424

; ---------------------  ASM Block 070  ---------------------


		lda #<title00dli
		sta vdslst+0
		lda #>title00dli
		sta vdslst+1
		lda #$22
		sta colbak
		lda mind_color
		sta colpf3		
inc_rt_clock
		inc rtclok+2
		bne no_inc_other_clock
		inc rtclok+1
		bne no_inc_other_clock
		inc rtclok
no_inc_other_clock	


      ;;  fillbyte(pointer(PMBNK0+prior_py),14,0);
      ;;  move(spriteframes[f],pointer(PMBNK0+character_py),14);
      ;;  hposp0:=character_px;


	  	LDA prior_py
	  	STA NDX2
	  	LDA >PMBNK0
	  	STA NDX3
	  	
	  	LDA #0
	  	LDY #13
Clear_Character_Prior_Loop
		STA (NDX2),Y
		DEY
		BPL Clear_Character_Prior_Loop   	
	  		
	  	LDA character_py
	    STA NDX2
	    LDA >PMBNK0
	    STA NDX3
	      
	    LDA F
	    ASL
	    TAY
	    
	    LDA adr.spriteframes + 0,Y
	    STA NDX0
	  	  
	    LDA adr.spriteframes + 1,Y
	    STA NDX1
	  	  	
	  	LDY #13
Copy_Character_Image_Loop
		LDA (NDX0),Y
		STA (NDX2),Y
		DEY
		BPL Copy_Character_Image_Loop
		
		LDA character_px
		STA HPOSP0   	
    
      	LDA character_py 
		STA prior_py 



		JSR PLAY_SOUNDS      



    

; ---------------------  ASM Block 071  ---------------------

		
		jmp XITVBV
	
	rti						; ret
.endl

.local	PAUSEVBI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 072  ---------------------


	
	
	
	
	rti						; ret
.endl

.local	TITLE00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 073  ---------------------


	pha	
	lda #$D8
	sta wsync
	sta colpf0
	lda #$06
	sta colpf1
	lda #$AA
	sta colpf2
	lda #>CHARSET_TITLE
	sta chbase
	lda #<title01dli
	sta vdslst+0
	lda #>title01dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 074  ---------------------


	pha	
	lda #142
	sta wsync
	sta colpf0
	lda #216
	sta colpf1
	lda #56
	sta colpf2
	lda #>CHARSET_GAME
 	sta chbase
	lda #<title00dli
	sta vdslst+0
	lda #>title00dli
	sta vdslst+1
	pla
	rti
	rti						; ret
.endl

.local	TITLE02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 075  ---------------------

phr
	plr
	rti						; ret
.endl

.local	TITLE03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 076  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME00DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 077  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME01DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 078  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME02DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 079  ---------------------

phr
	plr
	rti						; ret
.endl

.local	GAME03DLI					; PROCEDURE | ASSEMBLER | INTERRUPT


; ---------------------  ASM Block 080  ---------------------

phr
	plr
	rti						; ret
.endl

.local	SHOW_HI_SCORES					; PROCEDURE

	ift l_0431-*>3
	jmp l_0431
	eif

; IfThenEpilog
l_0431

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 524
	inx
	mva #$0A :STACKORIGIN,x
	inx
	mva #$06 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 525
	inx
	mva #$02 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 526
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$06 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0309', Mind Field.pas), line = 527
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0309

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 528
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 529
	inx
	mva #$0C :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF
; For

; optimize OK (Mind Field.pas), line = 530

	mva #$01 I

; optimize OK (Mind Field.pas), line = 530

; To
l_0450

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 530

	lda I
	cmp #$05
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_045E

; optimize OK (Mind Field.pas), line = 532

	ldy #1
	lda K
	cmp I
	beq @+
	dey
@
	.ifdef IFTMP_33
	sty IFTMP_33
	eif
	tya
	bne *+5
	jmp l_0472

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 534
	inx
	mva #$0C :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02E5', Mind Field.pas), line = 535
	inx
	mva #$0A :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02E5

; IfThenEpilog
l_0472

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 537
	inx
	mva #$0E :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02F9', Mind Field.pas), line = 538
	inx
	mva I :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02F9

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 539
	inx
	mva #$21 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 540
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$08 :STACKORIGIN,x
	inx
	mva I :STACKORIGIN,x
	jsr addAL_CL
	dex
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0309', Mind Field.pas), line = 541
	inx
	mva I :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	m@index2 0
	ldy :STACKORIGIN,x
	mva adr.HISCORE,y :STACKORIGIN,x
	mva adr.HISCORE+1,y :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0309

; ForToDoEpilog
c_0450
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0450
l_045E
b_0450

; -----------------------------------------------------------

@FORTMP_1098	= $0005

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	SHOW_OPTIONS_SCREEN				; PROCEDURE

	ift l_04A7-*>3
	jmp l_04A7
	eif

; IfThenEpilog
l_04A7

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	SHOWTITLESCREEN					; PROCEDURE

	ift l_04AB-*>3
	jmp l_04AB
	eif

; IfThenEpilog
l_04AB

; optimize OK (Mind Field.pas), line = 567

	lda #$00
	sta TOPMEM
	lda CHBASE1
	sta TOPMEM+1

; optimize OK (Mind Field.pas), line = 568

	mva #$00 TITLEPHASE

; ---------------------  ASM Block 082  ---------------------


;	  ICL "Atari 8-bit Equates.asm"
		
    lda #0
    sta 82
    sta 710
    lda #12
    sta 709
    ; lda chbase1
    ; sta 756
    LDA #0
    STA NMIEN
    STA DMACTL
    STA PRIOR
    STA HITCLR

;    LDX #>RamSizeCode+1
    LDY #$00
    STY NDX0
    STY NDX2
    LDA #$38
    STA NDX1
    LDA #$A8
    STA NDX3
    

; optimize OK (Mind Field.pas), line = 594

	mva #$00 ATARI.DMACTL

; optimize OK (Mind Field.pas), line = 595

	sta ATARI.NMIEN

; optimize FAIL ('B_CRT.CRT_INIT_0245', Mind Field.pas), line = 596
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$19 :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_0245

; optimize OK (Mind Field.pas), line = 597

	mva <TITLE00DLI VDSLST
	mva >TITLE00DLI VDSLST+1

; optimize FAIL ('B_SET_INTERUPTS.SETVBLI', Mind Field.pas), line = 599
	inx
	mva <TITLEVBI :STACKORIGIN,x
	mva >TITLEVBI :STACKORIGIN+STACKWIDTH,x
	jsr B_SET_INTERUPTS.SETVBLI

; optimize FAIL ('B_CRT.CRT_CLEAR_0293', Mind Field.pas), line = 600
	jsr B_CRT.CRT_CLEAR_0293

; optimize OK (Mind Field.pas), line = 601

	lda #$00
	sta :edx
	lda #$1C
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 602

	lda #$00
	sta :edx
	lda #$1D
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 603

	lda #$00
	sta :edx
	lda #$1E
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 604

	lda #$00
	sta :edx
	lda #$1F
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; --- RepeatUntilProlog
l_04E4

; optimize OK (Mind Field.pas), line = 606

	lda I
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda SCORE+1
	cmp :STACKORIGIN+STACKWIDTH+10
	bne @+
	lda SCORE
	cmp :STACKORIGIN+10
@
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_34
	sty IFTMP_34
	eif
	tya
	bne *+5
	jmp l_04F9

; optimize OK (Mind Field.pas), line = 608

	mva I K

; IfThenEpilog
l_04F9

; optimize OK (Mind Field.pas), line = 610

	dec I

; optimize OK (Mind Field.pas), line = 611

	ldy #1
	lda I
	beq @+
	dey
@
	tya
	bne *+5
c_04E4
	jmp l_04E4
b_04E4

; optimize OK (Mind Field.pas), line = 612

	ldy #1
	lda K
	cmp #$05
	bcc @+
	dey
@
	.ifdef IFTMP_35
	sty IFTMP_35
	eif
	tya
	bne *+5
	jmp l_0531

; optimize OK (Mind Field.pas), line = 614

	mva #$05 I

; --- RepeatUntilProlog
l_053A

; optimize OK (Mind Field.pas), line = 616

	lda I
	asl @
	sta :STACKORIGIN+9
	lda I
	sub #$01
	asl @
	tay
	lda adr.HISCORE,y
	sta :STACKORIGIN+10
	lda adr.HISCORE+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda :STACKORIGIN+10
	sta adr.HISCORE,y
	lda :STACKORIGIN+STACKWIDTH+10
	sta adr.HISCORE+1,y

; optimize OK (Mind Field.pas), line = 617

	dec I

; optimize OK (Mind Field.pas), line = 618

	ldy #1
	lda I
	cmp K
	beq @+
	dey
@
	tya
	bne *+5
c_053A
	jmp l_053A
b_053A

; optimize OK (Mind Field.pas), line = 619

	lda K
	asl @
	tay
	lda SCORE
	sta adr.HISCORE,y
	lda SCORE+1
	sta adr.HISCORE+1,y

; IfThenEpilog
l_0531

; optimize OK (Mind Field.pas), line = 622

	mva #$35 ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 623

	mva #$35 ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 624

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 625
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 626

	mva #$A4 ATARI.CHBAS

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 627
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 628
	inx
	mva #$25 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 629
	inx
	mva #$4F :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 630
	inx
	mva #$79 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 631
	inx
	mva #$A3 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 632
	inx
	mva #$CD :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize OK (Mind Field.pas), line = 633

	mva #$00 TMP5

; optimize OK (Mind Field.pas), line = 634

	mva #$01 ATARI.GPRIOR

; optimize OK (Mind Field.pas), line = 635

	sta ATARI.PRIOR

; optimize OK (Mind Field.pas), line = 636

	mva #$06 K

; optimize OK (Mind Field.pas), line = 637

	mva #$05 I

; optimize OK (Mind Field.pas), line = 639

	mva #$D8 ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 640

	mva #$06 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 641

	mva #$AA ATARI.COLOR2

; optimize OK (Mind Field.pas), line = 642

	mva #$36 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 643

	mva #$22 ATARI.COLOR4

; optimize FAIL ('B_PMG.PMG_INIT_03FF', Mind Field.pas), line = 645
	inx
	mva #$18 :STACKORIGIN,x
	inx
	mva #$3E :STACKORIGIN,x
	jsr B_PMG.PMG_INIT_03FF

; optimize OK (Mind Field.pas), line = 646

	mva #$C0 ATARI.NMIEN

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 648
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$0F :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 649
	inx
	mva #$F7 :STACKORIGIN,x
	mva #$80 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('SHOW_OPTIONS_SCREEN', Mind Field.pas), line = 650
	jsr SHOW_OPTIONS_SCREEN

; optimize FAIL ('SHOW_HI_SCORES', Mind Field.pas), line = 651
	jsr SHOW_HI_SCORES

; optimize OK (Mind Field.pas), line = 652

	lda #$00
	sta :bp+1
	ldy ATARI.HPOSP0
	lda #$7C
	sta (:bp),y

; --- RepeatUntilProlog
l_05F7

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 663
	jsr B_CRT.CRT_STARTPRESSED
	.ifdef IFTMP_36
	lda :STACKORIGIN,x
	sta IFTMP_36
	eif
	dex
	lda :STACKORIGIN+1,x
	bne *+5
	jmp l_0601

; optimize OK (Mind Field.pas), line = 663

	mva #$FF TMP5

; IfThenEpilog
l_0601

; optimize OK (Mind Field.pas), line = 667

	ldy #1
	lda TMP5
	cmp #$FF
	beq @+
	dey
@
	tya
	bne *+5
c_05F7
	jmp l_05F7
b_05F7

; optimize OK (Mind Field.pas), line = 669

	mva #$40 ATARI.NMIEN

; --- RepeatUntilProlog
l_0620

; optimize FAIL ('B_CRT.CRT_STARTPRESSED', Mind Field.pas), line = 671
	jsr B_CRT.CRT_STARTPRESSED
	inx
	mva #$00 :STACKORIGIN,x
	ldy #1
	lda :STACKORIGIN-1,x
	cmp :STACKORIGIN,x
	beq @+
	dey
@
	sty :STACKORIGIN-1,x
	dex
	dex
	lda :STACKORIGIN+1,x
	bne *+5
c_0620
	jmp l_0620
b_0620

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	INITIALIZE_LEVEL				; PROCEDURE

	ift l_062F-*>3
	jmp l_062F
	eif

; IfThenEpilog
l_062F

; optimize FAIL ('B_CRT.CRT_CLEAR_0293', Mind Field.pas), line = 684
	jsr B_CRT.CRT_CLEAR_0293

; optimize OK (Mind Field.pas), line = 685

	mva #$46 MIND_COLOR
; For

; optimize OK (Mind Field.pas), line = 686

	mva #$00 I

; optimize OK (Mind Field.pas), line = 686

; To
l_0646

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 686

	lda I
	cmp #$FF
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0654

; ---------------------  ASM Block 083  ---------------------


	LDA RANDOM
	CLC
	ADC #<game_screen
	STA NDX0
	LDA RANDOM
	AND #3
	ADC #>game_screen
	STA NDX1
	LDA RANDOM
	AND #3
	ORA #68
	LDY #0
	STA (NDX0),Y


; ForToDoEpilog
c_0646
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0646
l_0654
b_0646
; For

; optimize OK (Mind Field.pas), line = 707

	mva #$00 I

; optimize OK (Mind Field.pas), line = 707

; To
l_0668

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 707

	lda I
	cmp #$3F
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0676

; ---------------------  ASM Block 084  ---------------------


			LDA RANDOM
			CLC
			ADC #<game_screen
			STA NDX0
			LDA RANDOM
			AND #3
			ADC #>game_screen
			STA NDX1
			LDA #193
			LDY #0
			STA (NDX0),Y


; ForToDoEpilog
c_0668
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0668
l_0676
b_0668

; optimize OK (Mind Field.pas), line = 724

	mva #$7C CHARACTER_PX

; optimize OK (Mind Field.pas), line = 725

	mva #$D8 CHARACTER_PY

; optimize OK (Mind Field.pas), line = 726

	mva #$00 CHARACTER_STATUS

; optimize FAIL ('idivCARD', Mind Field.pas), line = 727
	inx
	mva CHARACTER_PX :STACKORIGIN,x
	inx
	mva #$30 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$04 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x A
	dex

; optimize FAIL ('idivCARD', Mind Field.pas), line = 728
	inx
	mva CHARACTER_PY :STACKORIGIN,x
	inx
	mva #$18 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$08 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x B
	dex
; For

; optimize OK (Mind Field.pas), line = 729

	lda B
	sub #$02
	sta J

; optimize OK (Mind Field.pas), line = 729

	lda B
	add #$03
	sta @FORTMP_1739
; To
l_06D1

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 729

	lda J
	cmp @FORTMP_1739
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_06DF
; For

; optimize OK (Mind Field.pas), line = 730

	lda A
	sub #$02
	sta I

; optimize OK (Mind Field.pas), line = 730

	lda A
	add #$03
	sta @FORTMP_1780
; To
l_06FA

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 730

	lda I
	cmp @FORTMP_1780
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0708

; optimize OK (Mind Field.pas), line = 732

	lda #$28
	add I
	sta :STACKORIGIN+9
	lda #$08
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda J
	sta :ecx
	lda #$28
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :STACKORIGIN+9
	add :eax
	sta C
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta C+1

; optimize OK (Mind Field.pas), line = 733

	lda C+1
	sta :bp+1
	ldy C
	lda (:bp),y
	sta E

; optimize OK (Mind Field.pas), line = 734

	ldy #1
	lda E
	cmp #$C1
	beq @+
	dey
@
	.ifdef IFTMP_37
	sty IFTMP_37
	eif
	tya
	bne *+5
	jmp l_073A

; optimize OK (Mind Field.pas), line = 734

	lda C+1
	sta :bp+1
	ldy C
	lda #$00
	sta (:bp),y

; IfThenEpilog
l_073A

; ForToDoEpilog
c_06FA
	inc I						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_06FA
l_0708
b_06FA

; ForToDoEpilog
c_06D1
	inc J						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_06D1
l_06DF
b_06D1

; optimize FAIL ('SYSTEM.RANDOM_0146', Mind Field.pas), line = 737
	inx
	mva #$13 :STACKORIGIN,x
	jsr SYSTEM.RANDOM_0146
	inx
	mva #$02 :STACKORIGIN,x
	jsr imulBYTE
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x EXIT_CX
	dex

; optimize OK (Mind Field.pas), line = 738

	mva #$00 EXIT_CY

; optimize OK (Mind Field.pas), line = 739

	lda EXIT_CX
	:2 asl @
	add #$2E
	sta EXIT_PL

; optimize OK (Mind Field.pas), line = 740

	lda EXIT_PL
	add #$08
	sta EXIT_PR

; optimize OK (Mind Field.pas), line = 741

	lda #$28
	add EXIT_CX
	sta :bp2
	lda #$08
	adc #$00
	sta :bp2+1
	ldy #$00
	lda #$4A
	sta (:bp2),y
	iny
	lda #$4B
	sta (:bp2),y

; optimize OK (Mind Field.pas), line = 742

	lda #$50
	add EXIT_CX
	sta :bp2
	lda #$08
	adc #$00
	sta :bp2+1
	ldy #$00
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; -----------------------------------------------------------

@FORTMP_1600	= $00FF
@FORTMP_1634	= $003F
@FORTMP_1739	= DATAORIGIN+$033E
@FORTMP_1780	= DATAORIGIN+$033F

@VarData	= @FORTMP_1739
@VarDataSize	= 2


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	DISPLAY_INFORMATION_LINE			; PROCEDURE

	ift l_0796-*>3
	jmp l_0796
	eif

; IfThenEpilog
l_0796

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 750
	inx
	mva #$00 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 751
	inx
	mva #$0E :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 752
	inx
	mva #$06 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_0309', Mind Field.pas), line = 753
	inx
	mva SCORE :STACKORIGIN,x
	mva SCORE+1 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_0309

; optimize OK (Mind Field.pas), line = 755

	ldy #1
	lda LIVES
	cmp #$FF
	bne @+
	dey
@
	.ifdef IFTMP_38
	sty IFTMP_38
	eif
	tya
	bne *+5
	jmp l_07B3

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 756
	inx
	mva #$0C :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 757
	inx
	mva #$16 :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 758
	inx
	mva #$12 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02F9', Mind Field.pas), line = 759
	inx
	mva LIVES :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02F9

; IfThenEpilog
l_07B3

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 762
	inx
	mva #$1A :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 763
	inx
	mva #$1E :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 764
	inx
	mva #$20 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02F9', Mind Field.pas), line = 765
	inx
	mva LEVEL :STACKORIGIN,x
	jsr B_CRT.CRT_WRITE_02F9

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	DISPLAY_GAME_OVER				; PROCEDURE

	ift l_07D2-*>3
	jmp l_07D2
	eif

; IfThenEpilog
l_07D2

; optimize FAIL ('B_CRT.CRT_GOTOXY', Mind Field.pas), line = 770
	inx
	mva #$0C :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr B_CRT.CRT_GOTOXY

; optimize FAIL ('B_CRT.CRT_WRITE_02CF', Mind Field.pas), line = 771
	inx
	mva #$26 :STACKORIGIN,x
	mva #$81 :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_02CF

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	START_SOUND_EFFECT				; PROCEDURE | ASSEMBLER | REGISTER

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SFSPEED
	dex						; sub bx, 1

; -----------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SFNUM
	dex						; sub bx, 1


; ---------------------  ASM Block 085  ---------------------


	LDX sfnum
	LDA sfspeed
	JSR START_SOUND


; -----------------------------------------------------------

SFNUM	= edx
SFSPEED	= ecx

@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	SILENCE_SOUND_EFFECTS				; PROCEDURE | ASSEMBLER


; ---------------------  ASM Block 086  ---------------------


	JSR SILENCE


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

.local	MAIN_GAME_LOOP					; PROCEDURE

	ift l_07E9-*>3
	jmp l_07E9
	eif

; IfThenEpilog
l_07E9

; --- RepeatUntilProlog
l_07EA

; optimize OK (Mind Field.pas), line = 793

	ldy #1
	lda PRIOR_RT_CLOCK
	cmp RT_CHECK
	bne @+
	dey
@
	.ifdef IFTMP_39
	sty IFTMP_39
	eif
	tya
	bne *+5
	jmp l_07FE

; optimize OK (Mind Field.pas), line = 794

	mva RT_CHECK PRIOR_RT_CLOCK

; optimize OK (Mind Field.pas), line = 795

	ldy #1
	lda SHOW_COUNTDOWN
	cmp #$00
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_40
	sty IFTMP_40
	eif
	tya
	bne *+5
	jmp l_081A

; optimize OK (Mind Field.pas), line = 796

	dec SHOW_COUNTDOWN

; IfThenEpilog
l_081A

; Restore conditional expression
	lda IFTMP_40

; else condition
	beq *+5						; je
	jmp l_0831

; optimize OK (Mind Field.pas), line = 797

	ldy #1
	lda MIND_COLOR
	cmp #$32
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_41
	sty IFTMP_41
	eif
	tya
	bne *+5
	jmp l_0843

; optimize OK (Mind Field.pas), line = 798

	dec MIND_COLOR

; optimize OK (Mind Field.pas), line = 799

	ldy #1
	lda MIND_COLOR
	cmp #$32
	beq @+
	dey
@
	.ifdef IFTMP_42
	sty IFTMP_42
	eif
	tya
	bne *+5
	jmp l_0863

; optimize OK (Mind Field.pas), line = 799

	mva #$22 MIND_COLOR

; IfThenEpilog
l_0863

; IfThenEpilog
l_0843

; IfThenEpilog
l_0831

; optimize OK (Mind Field.pas), line = 801

	ldy #1
	lda MIND_COLOR
	cmp #$22
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda SHOW_COUNTDOWN
	beq @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_43
	sta IFTMP_43
	eif
	bne *+5
	jmp l_088D

; optimize FAIL ('idivCARD', Mind Field.pas), line = 803
	inx
	mva CHARACTER_PX :STACKORIGIN,x
	inx
	mva #$2F :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$04 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x A
	dex

; optimize FAIL ('idivCARD', Mind Field.pas), line = 804
	inx
	mva CHARACTER_PY :STACKORIGIN,x
	inx
	mva #$18 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$08 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x B
	dex

; optimize OK (Mind Field.pas), line = 806

	ldy #1
	lda MINDS_FOUND
	cmp #$00
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_44
	sty IFTMP_44
	eif
	tya
	bne *+5
	jmp l_08C6
; For

; optimize OK (Mind Field.pas), line = 807

	lda B
	sub #$02
	sta J

; optimize OK (Mind Field.pas), line = 807

	lda B
	add #$03
	sta @FORTMP_2268
; To
l_08E2

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 807

	lda J
	cmp @FORTMP_2268
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_08F0

; optimize OK (Mind Field.pas), line = 808

	ldy #1
	lda J
	cmp #$00
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda J
	cmp #$19
	bcc @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_45
	sta IFTMP_45
	eif
	bne *+5
	jmp l_090E

; optimize OK (Mind Field.pas), line = 809

	lda J
	asl @
	tay
	lda adr.SCREEN_ROWS,y
	add A
	sta ROW_ADDR
	lda adr.SCREEN_ROWS+1,y
	adc #$00
	sta ROW_ADDR+1
; For

; optimize OK (Mind Field.pas), line = 810

	lda ROW_ADDR
	sub #$02
	sta C
	lda ROW_ADDR+1
	sbc #$00
	sta C+1

; optimize OK (Mind Field.pas), line = 810

	lda ROW_ADDR
	add #$03
	sta @FORTMP_2355
	lda ROW_ADDR+1
	adc #$00
	sta @FORTMP_2355+1
; To
l_0939

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 810

	lda C+1
	cmp @FORTMP_2355+1
	bne @+
	lda C
	cmp @FORTMP_2355
@
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0945

; optimize OK (Mind Field.pas), line = 812

	lda C+1
	sta :bp+1
	ldy C
	lda (:bp),y
	sta E

; optimize OK (Mind Field.pas), line = 813

	ldy #1
	lda E
	cmp #$41
	beq @+
	dey
@
	.ifdef IFTMP_46
	sty IFTMP_46
	eif
	tya
	bne *+5
	jmp l_0960

; optimize OK (Mind Field.pas), line = 813

	lda C+1
	sta :bp+1
	ldy C
	lda #$C1
	sta (:bp),y

; IfThenEpilog
l_0960

; ForToDoEpilog
c_0939
	inw C						; inc ptr word [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0939
l_0945
b_0939

; IfThenEpilog
l_090E

; ForToDoEpilog
c_08E2
	inc J						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_08E2
l_08F0
b_08E2

; IfThenEpilog
l_08C6

; optimize OK (Mind Field.pas), line = 817

	ldy #1
	lda CHARACTER_STATUS
	beq @+
	dey
@
	.ifdef IFTMP_47
	sty IFTMP_47
	eif
	tya
	bne *+5
	jmp l_0987

; optimize OK (Mind Field.pas), line = 818

	lda ATARI.PORTA
	and #$0F
	sta STICK_READ

; optimize OK (Mind Field.pas), line = 819

	lda RT_CHECK
	and #$04
	sta G

; optimize OK (Mind Field.pas), line = 826

	mva #$00 F

; optimize OK (Mind Field.pas), line = 827

	lda STICK_READ
	ldy #1
	and #$01
	beq @+
	dey
@
	.ifdef IFTMP_48
	sty IFTMP_48
	eif
	tya
	bne *+5
	jmp l_09BF

; optimize OK (Mind Field.pas), line = 828

	dec CHARACTER_PY

; optimize OK (Mind Field.pas), line = 829

	lda #$01
	add G
	sta F

; IfThenEpilog
l_09BF

; optimize OK (Mind Field.pas), line = 831

	lda STICK_READ
	ldy #1
	and #$02
	beq @+
	dey
@
	.ifdef IFTMP_49
	sty IFTMP_49
	eif
	tya
	bne *+5
	jmp l_09F2

; optimize OK (Mind Field.pas), line = 832

	inc CHARACTER_PY

; optimize OK (Mind Field.pas), line = 833

	ldy #1
	lda CHARACTER_PY
	cmp #$E8
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_50
	sty IFTMP_50
	eif
	tya
	bne *+5
	jmp l_0A12

; optimize OK (Mind Field.pas), line = 833

	mva #$E8 CHARACTER_PY

; IfThenEpilog
l_0A12

; optimize OK (Mind Field.pas), line = 834

	lda #$03
	add G
	sta F

; IfThenEpilog
l_09F2

; optimize OK (Mind Field.pas), line = 836

	lda STICK_READ
	ldy #1
	and #$04
	beq @+
	dey
@
	.ifdef IFTMP_51
	sty IFTMP_51
	eif
	tya
	bne *+5
	jmp l_0A41

; optimize OK (Mind Field.pas), line = 837

	dec CHARACTER_PX

; optimize OK (Mind Field.pas), line = 838

	ldy #1
	lda CHARACTER_PX
	cmp #$30
	bcc @+
	dey
@
	.ifdef IFTMP_52
	sty IFTMP_52
	eif
	tya
	bne *+5
	jmp l_0A61

; optimize OK (Mind Field.pas), line = 838

	mva #$30 CHARACTER_PX

; IfThenEpilog
l_0A61

; optimize OK (Mind Field.pas), line = 839

	lda #$02
	add G
	sta F

; IfThenEpilog
l_0A41

; optimize OK (Mind Field.pas), line = 841

	lda STICK_READ
	ldy #1
	and #$08
	beq @+
	dey
@
	.ifdef IFTMP_53
	sty IFTMP_53
	eif
	tya
	bne *+5
	jmp l_0A90

; optimize OK (Mind Field.pas), line = 842

	inc CHARACTER_PX

; optimize OK (Mind Field.pas), line = 843

	ldy #1
	lda CHARACTER_PX
	cmp #$C8
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_54
	sty IFTMP_54
	eif
	tya
	bne *+5
	jmp l_0AB0

; optimize OK (Mind Field.pas), line = 843

	mva #$C8 CHARACTER_PX

; IfThenEpilog
l_0AB0

; optimize OK (Mind Field.pas), line = 844

	lda #$04
	add G
	sta F

; IfThenEpilog
l_0A90

; optimize FAIL ('idivCARD', Mind Field.pas), line = 846
	inx
	mva CHARACTER_PX :STACKORIGIN,x
	inx
	mva #$2F :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$04 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x A
	dex

; optimize FAIL ('idivCARD', Mind Field.pas), line = 847
	inx
	mva CHARACTER_PY :STACKORIGIN,x
	inx
	mva #$18 :STACKORIGIN,x
	jsr @expandToCARD1.BYTE
	jsr @expandToCARD.BYTE
	jsr subEAX_ECX
	mva #$08 :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	jsr idivCARD
	jsr movaBX_EAX
	dex
	mva :STACKORIGIN,x B
	dex

; optimize OK (Mind Field.pas), line = 848

	mva #$CA ATARI.COLPM0

; optimize OK (Mind Field.pas), line = 849

	mva #$00 G
; For

; optimize OK (Mind Field.pas), line = 850

	lda B
	sub #$02
	sta J

; optimize OK (Mind Field.pas), line = 850

	lda B
	add #$03
	sta @FORTMP_2834
; To
l_0B18

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 850

	lda J
	cmp @FORTMP_2834
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0B26

; optimize OK (Mind Field.pas), line = 851

	ldy #1
	lda J
	cmp #$00
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda J
	cmp #$19
	bcc @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_55
	sta IFTMP_55
	eif
	bne *+5
	jmp l_0B44

; optimize OK (Mind Field.pas), line = 852

	lda J
	asl @
	tay
	lda adr.SCREEN_ROWS,y
	add A
	sta ROW_ADDR
	lda adr.SCREEN_ROWS+1,y
	adc #$00
	sta ROW_ADDR+1

; optimize OK (Mind Field.pas), line = 853

	mva #$00 H
; For

; optimize OK (Mind Field.pas), line = 854

	lda ROW_ADDR
	sub #$02
	sta C
	lda ROW_ADDR+1
	sbc #$00
	sta C+1

; optimize OK (Mind Field.pas), line = 854

	lda ROW_ADDR
	add #$03
	sta @FORTMP_2928
	lda ROW_ADDR+1
	adc #$00
	sta @FORTMP_2928+1
; To
l_0B76

; ForToDoCondition

; optimize OK (Mind Field.pas), line = 854

	lda C+1
	cmp @FORTMP_2928+1
	bne @+
	lda C
	cmp @FORTMP_2928
@
	bcc *+7
	beq *+5

; ForToDoProlog
	jmp l_0B82

; optimize OK (Mind Field.pas), line = 855

	lda C+1
	sta :bp+1
	ldy C
	lda (:bp),y
	sta E

; optimize OK (Mind Field.pas), line = 856

	ldy #1
	lda E
	cmp #$C1
	beq @+
	dey
@
	.ifdef IFTMP_56
	sty IFTMP_56
	eif
	tya
	bne *+5
	jmp l_0B9D

; optimize OK (Mind Field.pas), line = 857

	lda C+1
	sta :bp+1
	ldy C
	lda #$41
	sta (:bp),y

; optimize OK (Mind Field.pas), line = 858

	mva #$01 MINDS_FOUND

; optimize OK (Mind Field.pas), line = 859

	ldy #1
	lda G
	cmp #$01
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda G
	cmp #$02
	beq @+
	dey
@
	tya
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	ldy #1
	lda H
	cmp #$02
	beq @+
	dey
@
	sty :STACKORIGIN+10
	ldy #1
	lda H
	cmp #$03
	beq @+
	dey
@
	tya
	ora :STACKORIGIN+10
	and :STACKORIGIN+9
	.ifdef IFTMP_57
	sta IFTMP_57
	eif
	bne *+5
	jmp l_0BDF

; optimize OK (Mind Field.pas), line = 860

	mva #$0F ATARI.COLPM0

; optimize OK (Mind Field.pas), line = 861

	mva #$01 CHARACTER_STATUS

; optimize FAIL ('START_SOUND_EFFECT', Mind Field.pas), line = 862
	inx
	mva #$00 :STACKORIGIN,x
	inx
	mva #$01 :STACKORIGIN,x
	jsr START_SOUND_EFFECT

; IfThenEpilog
l_0BDF

; IfThenEpilog
l_0B9D

; optimize OK (Mind Field.pas), line = 865

	inc H

; ForToDoEpilog
c_0B76
	inw C						; inc ptr word [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0B76
l_0B82
b_0B76

; IfThenEpilog
l_0B44

; optimize OK (Mind Field.pas), line = 868

	inc G

; ForToDoEpilog
c_0B18
	inc J						; inc ptr byte [CounterAddress]

	seq

; WhileDoEpilog
	jmp l_0B18
l_0B26
b_0B18

; optimize OK (Mind Field.pas), line = 870

	ldy #1
	lda CHARACTER_PY
	cmp #$26
	bcc @+
	dey
@
	.ifdef IFTMP_58
	sty IFTMP_58
	eif
	tya
	bne *+5
	jmp l_0C2D

; optimize OK (Mind Field.pas), line = 871

	mva #$26 CHARACTER_PY

; optimize OK (Mind Field.pas), line = 872

	ldy #1
	lda CHARACTER_PX
	cmp EXIT_PL
	seq
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda CHARACTER_PX
	cmp EXIT_PR
	bcc @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_59
	sta IFTMP_59
	eif
	bne *+5
	jmp l_0C57

; optimize OK (Mind Field.pas), line = 873

	ldy #1
	lda CHARACTER_STATUS
	beq @+
	dey
@
	.ifdef IFTMP_60
	sty IFTMP_60
	eif
	tya
	bne *+5
	jmp l_0C6A

; optimize OK (Mind Field.pas), line = 874

	mva #$20 CHARACTER_STATUS

; optimize FAIL ('START_SOUND_EFFECT', Mind Field.pas), line = 875
	inx
	mva #$01 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	jsr START_SOUND_EFFECT

; IfThenEpilog
l_0C6A

; IfThenEpilog
l_0C57

; IfThenEpilog
l_0C2D

; IfThenEpilog
l_0987

; optimize OK (Mind Field.pas), line = 880

	ldy #1
	lda CHARACTER_STATUS
	cmp #$00
	seq
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda CHARACTER_STATUS
	cmp #$1F
	bcc @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_61
	sta IFTMP_61
	eif
	bne *+5
	jmp l_0C9B

; optimize OK (Mind Field.pas), line = 881

	inc CHARACTER_STATUS

; optimize OK (Mind Field.pas), line = 882

	ldy #1
	lda CHARACTER_STATUS
	cmp #$1E
	beq @+
	dey
@
	.ifdef IFTMP_62
	sty IFTMP_62
	eif
	tya
	bne *+5
	jmp l_0CBB

; optimize OK (Mind Field.pas), line = 882

	mva #$80 CHARACTER_STATUS

; IfThenEpilog
l_0CBB

; optimize OK (Mind Field.pas), line = 883

	ldy #1
	lda CHARACTER_STATUS
	cmp #$10
	bcc @+
	dey
@
	.ifdef IFTMP_63
	sty IFTMP_63
	eif
	tya
	bne *+5
	jmp l_0CD7

; optimize OK (Mind Field.pas), line = 884

	lda CHARACTER_STATUS
	sta al
	lda #$04
	sta cl
	jsr idivAL_CL
	lda #$10
	add :eax
	sta F

; IfThenEpilog
l_0CD7

; optimize OK (Mind Field.pas), line = 886

	ldy #1
	lda CHARACTER_STATUS
	cmp #$0F
	seq
	bcs @+
	dey
@
	.ifdef IFTMP_64
	sty IFTMP_64
	eif
	tya
	bne *+5
	jmp l_0CFF

; optimize OK (Mind Field.pas), line = 887

	mva #$13 F

; optimize OK (Mind Field.pas), line = 888

	mva #$00 CHARACTER_PX

; IfThenEpilog
l_0CFF

; IfThenEpilog
l_0C9B

; optimize OK (Mind Field.pas), line = 891

	ldy #1
	lda CHARACTER_STATUS
	cmp #$1F
	seq
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda CHARACTER_STATUS
	cmp #$40
	bcc @+
	dey
@
	tya
	and :STACKORIGIN+9
	.ifdef IFTMP_65
	sta IFTMP_65
	eif
	bne *+5
	jmp l_0D30

; optimize OK (Mind Field.pas), line = 892

	inc CHARACTER_STATUS

; optimize OK (Mind Field.pas), line = 893

	ldy #1
	lda CHARACTER_STATUS
	cmp #$40
	beq @+
	dey
@
	.ifdef IFTMP_66
	sty IFTMP_66
	eif
	tya
	bne *+5
	jmp l_0D50

; optimize OK (Mind Field.pas), line = 893

	mva #$90 CHARACTER_STATUS

; IfThenEpilog
l_0D50

; optimize OK (Mind Field.pas), line = 894

	lda CHARACTER_STATUS
	and #$01
	ldy #1
	cmp #$01
	beq @+
	dey
@
	.ifdef IFTMP_67
	sty IFTMP_67
	eif
	tya
	bne *+5
	jmp l_0D70

; optimize OK (Mind Field.pas), line = 895

	lda #$28
	add EXIT_CX
	sta :bp2
	lda #$08
	adc #$00
	sta :bp2+1
	ldy #$00
	lda #$4A
	sta (:bp2),y
	iny
	lda #$4B
	sta (:bp2),y

; IfThenEpilog
l_0D70

; Restore conditional expression
	lda IFTMP_67

; else condition
	beq *+5						; je
	jmp l_0D83

; optimize OK (Mind Field.pas), line = 897

	lda #$28
	add EXIT_CX
	sta :bp2
	lda #$08
	adc #$00
	sta :bp2+1
	ldy #$00
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; IfThenEpilog
l_0D83

; IfThenEpilog
l_0D30

; IfThenEpilog
l_088D

; IfThenEpilog
l_07FE

; optimize FAIL ('B_CRT.CRT_KEYPRESSED', Mind Field.pas), line = 910
	jsr B_CRT.CRT_KEYPRESSED
	.ifdef IFTMP_68
	lda :STACKORIGIN,x
	sta IFTMP_68
	eif
	dex
	lda :STACKORIGIN+1,x
	bne *+5
	jmp l_0D9C

; optimize OK (Mind Field.pas), line = 910

	mva #$84 CHARACTER_STATUS

; IfThenEpilog
l_0D9C

; optimize OK (Mind Field.pas), line = 911

	ldy #1
	lda CHARACTER_STATUS
	bmi @+
	dey
@
	tya
	bne *+5
c_07EA
	jmp l_07EA
b_07EA

; -----------------------------------------------------------

IFTMP_40	= DATAORIGIN+$0340
@FORTMP_2268	= DATAORIGIN+$0341
@FORTMP_2355	= DATAORIGIN+$0342
@FORTMP_2834	= DATAORIGIN+$0344
@FORTMP_2928	= DATAORIGIN+$0345
IFTMP_67	= DATAORIGIN+$0347

@VarData	= IFTMP_40
@VarDataSize	= 8


@exit
	.ifdef @new
	@FreeMem #@VarData #@VarDataSize
	eif
	rts						; ret
.endl

; IfThenEpilog
l_013C

; optimize OK (Mind Field.pas), line = 923

	mva #$00 SCORE
	sta SCORE+1

; --- RepeatUntilProlog
l_0DBC

; optimize FAIL ('SILENCE_SOUND_EFFECTS', Mind Field.pas), line = 925
	jsr SILENCE_SOUND_EFFECTS

; optimize FAIL ('SHOWTITLESCREEN', Mind Field.pas), line = 926
	jsr SHOWTITLESCREEN

; optimize OK (Mind Field.pas), line = 927

	mva #$00 SCORE
	sta SCORE+1

; optimize OK (Mind Field.pas), line = 928

	mva #$05 LIVES

; optimize OK (Mind Field.pas), line = 929

	mva #$01 LEVEL

; optimize OK (Mind Field.pas), line = 930

	mva #$00 CHARACTER_STATUS

; optimize FAIL ('B_CRT.CRT_INIT_0245', Mind Field.pas), line = 931
	inx
	mva #$00 :STACKORIGIN,x
	mva #$08 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$28 :STACKORIGIN,x
	inx
	mva #$1A :STACKORIGIN,x
	jsr B_CRT.CRT_INIT_0245

; optimize FAIL ('B_CRT.CRT_CLEAR_0293', Mind Field.pas), line = 934
	jsr B_CRT.CRT_CLEAR_0293

; optimize OK (Mind Field.pas), line = 935

	lda #$00
	sta :edx
	lda #$1C
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 936

	lda #$00
	sta :edx
	lda #$1D
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 937

	lda #$00
	sta :edx
	lda #$1E
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 938

	lda #$00
	sta :edx
	lda #$1F
	sta :edx+1
	lda #$FF
	sta :ecx
	lda #$00
	sta :ecx+1
	sta :eax
	jsr @fill

; optimize OK (Mind Field.pas), line = 940

	mva #$6A ATARI.DLISTW
	mva #$82 ATARI.DLISTW+1

; optimize OK (Mind Field.pas), line = 941

	mva #$6A ATARI.SDLSTW
	mva #$82 ATARI.SDLSTW+1

; optimize OK (Mind Field.pas), line = 942

	mva #$00 ATARI.SAVMSC
	mva #$08 ATARI.SAVMSC+1

; optimize FAIL ('B_SYSTEM.SETCHARSET', Mind Field.pas), line = 943
	inx
	mva #$A4 :STACKORIGIN,x
	jsr B_SYSTEM.SETCHARSET

; optimize OK (Mind Field.pas), line = 944

	mva #$A4 ATARI.CHBAS

; --- RepeatUntilProlog
l_0E0E

; optimize FAIL ('INITIALIZE_LEVEL', Mind Field.pas), line = 946
	jsr INITIALIZE_LEVEL

; optimize FAIL ('SILENCE_SOUND_EFFECTS', Mind Field.pas), line = 947
	jsr SILENCE_SOUND_EFFECTS

; optimize OK (Mind Field.pas), line = 948

	mva #$8E ATARI.COLOR0

; optimize OK (Mind Field.pas), line = 949

	mva #$D4 ATARI.COLOR1

; optimize OK (Mind Field.pas), line = 950

	mva #$96 ATARI.COLOR3

; optimize OK (Mind Field.pas), line = 951

	mva #$22 ATARI.COLOR4

; optimize OK (Mind Field.pas), line = 952

	mva #$CA ATARI.COLPM0

; optimize OK (Mind Field.pas), line = 953

	mva #$FA ATARI.COLPM1

; optimize OK (Mind Field.pas), line = 954

	mva #$88 ATARI.COLPM2

; optimize OK (Mind Field.pas), line = 955

	mva #$24 ATARI.COLPM3

; optimize OK (Mind Field.pas), line = 956

	mva #$00 ATARI.SIZEP0

; optimize OK (Mind Field.pas), line = 957

	sta ATARI.SIZEP1

; optimize OK (Mind Field.pas), line = 958

	sta ATARI.SIZEP2

; optimize OK (Mind Field.pas), line = 959

	sta ATARI.SIZEP3

; optimize FAIL ('B_PMG.PMG_INIT_03FF', Mind Field.pas), line = 960
	inx
	mva #$18 :STACKORIGIN,x
	inx
	mva #$3E :STACKORIGIN,x
	jsr B_PMG.PMG_INIT_03FF

; optimize FAIL ('DISPLAY_INFORMATION_LINE', Mind Field.pas), line = 961
	jsr DISPLAY_INFORMATION_LINE

; optimize FAIL ('B_SET_INTERUPTS.SETVBLI', Mind Field.pas), line = 962
	inx
	mva <GAMEVBI :STACKORIGIN,x
	mva >GAMEVBI :STACKORIGIN+STACKWIDTH,x
	jsr B_SET_INTERUPTS.SETVBLI

; optimize OK (Mind Field.pas), line = 963

	mva #$C0 ATARI.NMIEN

; optimize OK (Mind Field.pas), line = 965

	mva #$B4 SHOW_COUNTDOWN

; optimize OK (Mind Field.pas), line = 966

	mva #$3F MIND_COLOR

; optimize OK (Mind Field.pas), line = 968

	mva #$00 F

; optimize OK (Mind Field.pas), line = 969

	mva RT_CHECK PRIOR_RT_CLOCK

; optimize FAIL ('MAIN_GAME_LOOP', Mind Field.pas), line = 971
	jsr MAIN_GAME_LOOP

; optimize OK (Mind Field.pas), line = 973

	ldy #1
	lda CHARACTER_STATUS
	cmp #$80
	beq @+
	dey
@
	.ifdef IFTMP_69
	sty IFTMP_69
	eif
	tya
	bne *+5
	jmp l_0EA1

; optimize OK (Mind Field.pas), line = 974

	dec LIVES

; optimize OK (Mind Field.pas), line = 975

	ldy #1
	lda LIVES
	cmp #$FF
	beq @+
	dey
@
	.ifdef IFTMP_70
	sty IFTMP_70
	eif
	tya
	bne *+5
	jmp l_0EC1

; optimize OK (Mind Field.pas), line = 976

	mva #$9F CHARACTER_STATUS

; optimize OK (Mind Field.pas), line = 977

	mva #$00 CHARACTER_PX

; optimize FAIL ('DISPLAY_GAME_OVER', Mind Field.pas), line = 978
	jsr DISPLAY_GAME_OVER

; IfThenEpilog
l_0EC1

; IfThenEpilog
l_0EA1

; optimize OK (Mind Field.pas), line = 981

	ldy #1
	lda CHARACTER_STATUS
	cmp #$90
	beq @+
	dey
@
	.ifdef IFTMP_71
	sty IFTMP_71
	eif
	tya
	bne *+5
	jmp l_0EE7

; optimize OK (Mind Field.pas), line = 982

	lda SCORE
	add #$0A
	sta SCORE
	scc
	inc SCORE+1

; optimize OK (Mind Field.pas), line = 983

	inc LEVEL

; IfThenEpilog
l_0EE7

; optimize OK (Mind Field.pas), line = 985

	ldy #1
	lda CHARACTER_STATUS
	cmp #$9F
	beq @+
	dey
@
	tya
	bne *+5
c_0E0E
	jmp l_0E0E
b_0E0E

; optimize OK (Mind Field.pas), line = 986

	ldy #1
	lda CHARACTER_STATUS
	cmp #$9F
	beq @+
	dey
@
	.ifdef IFTMP_72
	sty IFTMP_72
	eif
	tya
	bne *+5
	jmp l_0F22

; --- RepeatUntilProlog
l_0F24

; optimize OK (Mind Field.pas), line = 988

	ldy #1
	lda PRIOR_RT_CLOCK
	cmp RT_CHECK
	bne @+
	dey
@
	.ifdef IFTMP_73
	sty IFTMP_73
	eif
	tya
	bne *+5
	jmp l_0F38

; optimize OK (Mind Field.pas), line = 989

	dec CHARACTER_STATUS

; optimize OK (Mind Field.pas), line = 990

	mva RT_CHECK PRIOR_RT_CLOCK

; IfThenEpilog
l_0F38

; optimize OK (Mind Field.pas), line = 992

	ldy #1
	lda CHARACTER_STATUS
	cmp #$50
	beq @+
	dey
@
	tya
	bne *+5
c_0F24
	jmp l_0F24
b_0F24
l_0F22

; optimize OK (Mind Field.pas), line = 994

	lda #$00
	bne *+5
c_0DBC
	jmp l_0DBC
b_0DBC

; -----------------------------------------------------------

SCREEN_ADDR	= $0800
GAME_SCREEN	= $0828
PMBANK	= $1800
VARBANK	= $0600
LOCALVAR	= $06E0
CHARSET_GAME	= $A400
CHARSET_TITLE	= $A800
TITLE_DATA	= $AC00
SOUND_COMMANDER	= $AE00
CHARSET_BASE	= $00A4
PLAY_SOUNDS	= $AE00
START_SOUND	= $AE9F
GET_NEXT_MUSIC_NOTE	= $AEF6
STOP_SOUND	= $AF89
SILENCE	= $AF9E
MIBANK	= $1B00
PMBNK0	= $1C00
PMBNK1	= $1D00
PMBNK2	= $1E00
PMBNK3	= $1F00
adr.DISPLAY_LIST_TITLE	= CODEORIGIN+$0235
.var DISPLAY_LIST_TITLE	= adr.DISPLAY_LIST_TITLE .word
adr.DISPLAY_LIST_GAME	= CODEORIGIN+$026A
.var DISPLAY_LIST_GAME	= adr.DISPLAY_LIST_GAME .word
adr.SCREEN_ROWS	= CODEORIGIN+$028D
.var SCREEN_ROWS	= adr.SCREEN_ROWS .word
adr.P000	= CODEORIGIN+$02C1
.var P000	= adr.P000 .word
adr.P001	= CODEORIGIN+$02CF
.var P001	= adr.P001 .word
adr.P002	= CODEORIGIN+$02DD
.var P002	= adr.P002 .word
adr.P003	= CODEORIGIN+$02EB
.var P003	= adr.P003 .word
adr.P004	= CODEORIGIN+$02F9
.var P004	= adr.P004 .word
adr.P005	= CODEORIGIN+$0307
.var P005	= adr.P005 .word
adr.P006	= CODEORIGIN+$0315
.var P006	= adr.P006 .word
adr.P007	= CODEORIGIN+$0323
.var P007	= adr.P007 .word
adr.P008	= CODEORIGIN+$0331
.var P008	= adr.P008 .word
adr.P009	= CODEORIGIN+$033F
.var P009	= adr.P009 .word
adr.P010	= CODEORIGIN+$034D
.var P010	= adr.P010 .word
adr.P011	= CODEORIGIN+$035B
.var P011	= adr.P011 .word
adr.P012	= CODEORIGIN+$0369
.var P012	= adr.P012 .word
adr.P013	= CODEORIGIN+$0377
.var P013	= adr.P013 .word
adr.P014	= CODEORIGIN+$0385
.var P014	= adr.P014 .word
adr.P015	= CODEORIGIN+$0393
.var P015	= adr.P015 .word
adr.P016	= CODEORIGIN+$03A1
.var P016	= adr.P016 .word
adr.P017	= CODEORIGIN+$03AF
.var P017	= adr.P017 .word
adr.P018	= CODEORIGIN+$03BD
.var P018	= adr.P018 .word
adr.P019	= CODEORIGIN+$03CB
.var P019	= adr.P019 .word
adr.SPRITEFRAMES	= CODEORIGIN+$03D9
.var SPRITEFRAMES	= adr.SPRITEFRAMES .word
RT_CHECK	= $0014
PRIOR	= $D01B
TMP0	= $00E0
TMP1	= $00E1
TMP2	= $00E2
TMP3	= $00E3
TMP4	= $00E4
TMP5	= $00E5
TMP6	= $00E6
TMP7	= $00E7
TMP8	= $00E8
TMP9	= $00E9
NDX0	= $00EA
NDX1	= $00EB
NDX2	= $00EC
NDX3	= $00ED
HOLDX	= $00EE
HOLDY	= $00EF
A	= $0600
B	= $0602
C	= $0604
D	= $0606
E	= $0608
F	= $060A
G	= $060C
H	= $060E
I	= $0610
J	= $0612
K	= $0614
L	= $0616
CHARACTER_PX	= $0620
CHARACTER_PY	= $0621
CHARACTER_STATUS	= $0622
PRIOR_PY	= $0624
STICK_READ	= $0626
PRIOR_RT_CLOCK	= $0628
MENU_SELECTION	= $062A
FIND_OPTION	= $062C
BOMBS_ON_OPTION	= $062E
WALLS_ON_OPTION	= $0630
SHOOTERS_OPTION	= $0632
MIND_COLOR	= $0634
SHOW_COUNTDOWN	= $0636
MINDS_FOUND	= $0638
MINDS_UNDER	= $063A
TITLEPHASE	= $063C
SCORE	= $063E
LIVES	= $0640
LEVEL	= $0641
TOPMEM	= $0642
CHBASE1	= $0644
ROW_ADDR	= $0646
EXIT_CX	= $0648
EXIT_CY	= $0649
EXIT_PL	= $064A
EXIT_PR	= $064B
adr.HISCORE	= $0700
.var HISCORE	= adr.HISCORE .word

@exit

@halt	ldx #0
	txs

	rts

IOCB@COPY	:16 brk

.local	@DEFINES
ATARI
PLATFORM_ATARI_ANTIC
PLATFORM_ATARI_8_BIT
.endl

.endl

; -----------------------------------------------------------

	icl 'cpu6502.asm'

; -----------------------------------------------------------

.macro UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	eif

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SYSTEM.@UnitInit
	jsr MAIN.B_SYSTEM.@UnitInit
	eif

	.ifdef MAIN.SYSUTILS.@UnitInit
	jsr MAIN.SYSUTILS.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_CRT.@UnitInit
	jsr MAIN.B_CRT.@UnitInit
	eif

	.ifdef MAIN.B_PMG.@UnitInit
	jsr MAIN.B_PMG.@UnitInit
	eif

	.ifdef MAIN..@UnitInit
	jsr MAIN..@UnitInit
	eif

	.ifdef MAIN.B_SET_INTERUPTS.@UnitInit
	jsr MAIN.B_SET_INTERUPTS.@UnitInit
	eif
.endm

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.B_SYSTEM) > 0
	.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.SYSUTILS) > 0
	.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
	eif

	ift .SIZEOF(MAIN.B_CRT) > 0
	.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
	eif

	ift .SIZEOF(MAIN.B_PMG) > 0
	.print 'B_PMG: ',MAIN.B_PMG,'..',MAIN.B_PMG+.SIZEOF(MAIN.B_PMG)-1
	eif

	ift .SIZEOF(MAIN.B_SET_INTERUPTS) > 0
	.print 'B_SET_INTERUPTS: ',MAIN.B_SET_INTERUPTS,'..',MAIN.B_SET_INTERUPTS+.SIZEOF(MAIN.B_SET_INTERUPTS)-1
	eif

	.print 'CODE: ',CODEORIGIN,'..',*-1

	org $A000

DATAORIGIN

.by  $28 $00 $18 $00 $0C $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $03 $0E

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 840

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	run START

; -----------------------------------------------------------

.macro	STATICDATA
.by  $00 $00 $08 $33 $23 $2F $32 $25  $00 $1A $00 $00 $13 $34 $2F $24  $21 $39 $33 $00 $28 $29 $27 $28
.by  $00 $33 $23 $2F $32 $25 $33 $0E  $00 $02 $00 $1A $00 $28 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $21 $34 $21 $32 $29 $00 $18  $0D $22 $29 $34 $00 $36 $25 $32  $33 $29 $2F $2E $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $28  $00 $30 $32 $2F $27 $32 $21 $2D  $2D $29 $2E $27 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $30 $25 $34 $25 $32 $00 $2A  $0E $00 $2D $25 $39 $25 $32 $00
.by  $00 $28 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $08 $39 $2F $35 $32 $00 $2E $21
.by  $2D $25 $00 $23 $2F $35 $2C $24  $00 $22 $25 $00 $28 $25 $32 $25  $09 $00 $00 $28 $00 $27 $32 $21
.by  $30 $28 $29 $23 $33 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $28 $00 $33  $2F $35 $2E $24 $00 $21 $2E $24
.by  $00 $2D $35 $33 $29 $23 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $15  $30 $32 $25 $33 $33 $00 $33 $34  $21 $32 $34 $00 $34 $2F $00 $22
.by  $25 $27 $29 $2E $0E $00 $06 $33  $23 $2F $32 $25 $1A $00 $06 $2C  $29 $36 $25 $33 $1A $00 $06 $2C
.by  $25 $36 $25 $2C $1A $00 $0D $27  $21 $2D $25 $00 $2F $36 $25 $32  $00 $00 $00 $00 $00 $6C $6A $3B
.by  $FF $FF $6B $2B $2A $6F $FF $70  $75 $9B $69 $2D $3D $76 $FF $63  $FF $FF $62 $78 $7A $34 $FF $33
.by  $36 $1B $35 $32 $31 $2C $20 $2E  $6E $FF $6D $2F $81 $72 $FF $65  $79 $7F $74 $77 $71 $39 $FF $30
.by  $37 $7E $38 $3E $FF $66 $68 $64  $FF $82 $67 $73 $61 $4C $4A $3A  $FF $FF $4B $5C $5E $4F $FF $50
.by  $55 $FF $49 $5F $7C $56 $FF $43  $FF $FF $42 $58 $5A $24 $FF $23  $26 $FF $25 $22 $21 $5B $3B $5D
.by  $4E $FF $4D $3F $FF $52 $FF $45  $59 $FF $54 $57 $51 $28 $FF $29  $27 $FF $40 $FF $FF $46 $48 $44
.by  $FF $FF $47 $53 $41 $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $70 $C0 $44  $00 $AC $04 $04 $04 $04 $04 $04
.by  $84 $00 $44 $00 $08 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $00
.by  $04 $00 $04 $00 $04 $00 $04 $00  $04 $00 $04 $00 $04 $00 $04 $41  $35 $82 $70 $70 $44 $00 $08 $10
.by  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04  $04 $04 $04 $04 $04 $04 $04 $04
.by  $04 $04 $41 $6A $82 $28 $08 $50  $08 $78 $08 $A0 $08 $C8 $08 $F0  $08 $18 $09 $40 $09 $68 $09 $90
.by  $09 $B8 $09 $E0 $09 $08 $0A $30  $0A $58 $0A $80 $0A $A8 $0A $D0  $0A $F8 $0A $20 $0B $48 $0B $70
.by  $0B $98 $0B $C0 $0B $E8 $0B $10  $0C $10 $38 $38 $7C $7C $7C $7C  $38 $38 $38 $28 $28 $28 $28 $10
.by  $38 $38 $78 $78 $7C $7E $3A $3A  $38 $28 $2C $24 $20 $1C $1C $0C  $1E $3E $3E $1E $1C $18 $18 $18
.by  $1C $1C $14 $10 $38 $38 $3C $3C  $7C $FC $B8 $B8 $38 $28 $2C $24  $20 $1C $1C $18 $3C $3E $3E $3C
.by  $1C $0C $0C $0C $1C $1C $14 $10  $38 $38 $3C $3C $7C $FC $B8 $B8  $38 $28 $68 $48 $48 $1C $1C $0C
.by  $1C $1E $1D $3E $3C $18 $18 $24  $22 $41 $41 $10 $38 $38 $78 $78  $7C $7E $3A $3A $38 $28 $68 $48
.by  $48 $1C $1C $18 $1C $3C $5C $3E  $1E $0C $0C $12 $22 $41 $41 $C3  $C3 $66 $3C $18 $3C $7E $7E $7E
.by  $7E $7E $7E $3C $18 $00 $C6 $C6  $6C $38 $38 $7C $7C $7C $7C $7C  $7C $38 $10 $00 $66 $66 $3C $18
.by  $18 $3C $3C $3C $3C $3C $3C $18  $00 $00 $00 $C3 $66 $3C $18 $3C  $7E $7E $7E $7E $18 $00 $00 $00
.by  $00 $C6 $6C $38 $10 $38 $7C $7C  $7C $7C $38 $00 $00 $00 $00 $00  $66 $3C $18 $18 $3C $3C $3C $18
.by  $00 $00 $00 $00 $00 $00 $00 $6C  $38 $10 $38 $38 $38 $10 $00 $00  $00 $00 $00 $00 $00 $18 $24 $24
.by  $24 $24 $18 $00 $00 $00 $00 $00  $00 $18 $24 $42 $42 $42 $42 $42  $42 $24 $18 $00 $00 $00 $18 $24
.by  $42 $81 $81 $81 $81 $81 $81 $42  $24 $18 $00 $3C $42 $42 $81 $81  $81 $81 $81 $81 $81 $81 $42 $42
.by  $3C $C1 $82 $CF $82 $DD $82 $EB  $82 $F9 $82 $07 $83 $15 $83 $23  $83 $31 $83 $3F $83 $4D $83 $5B
.by  $83 $69 $83 $77 $83 $85 $83 $93  $83 $A1 $83 $AF $83 $BD $83 $CB  $83
.endm

	end
